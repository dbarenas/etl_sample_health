# api/database.py
from sqlalchemy import create_engine, Column, Integer, String, Date, Float, DateTime, ForeignKey, Numeric, Index
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.dialects.postgresql import TIMESTAMP # For PostgreSQL timestamp with timezone
import os
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists (for local development outside Docker)
# Docker Compose will provide these environment variables directly.
load_dotenv()

DATABASE_URL = os.getenv("API_DATABASE_URL") # Fallback to a general one if API specific isn't set
if not DATABASE_URL:
    DB_USER = os.getenv("DB_USER", "etl_user")
    DB_PASSWORD = os.getenv("DB_PASSWORD", "etl_password")
    DB_HOST = os.getenv("DB_HOST", "db")
    DB_PORT = os.getenv("DB_PORT", "5432")
    DB_NAME = os.getenv("DB_NAME", "etl_data")
    DATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

engine = create_engine(DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# --- SQLAlchemy ORM Models ---

class Patient(Base):
    __tablename__ = "patients"

    id = Column(String, primary_key=True, index=True) # Match DDL: VARCHAR(255)
    name = Column(String, nullable=False, index=True)
    dob = Column(Date)
    gender = Column(String)
    address = Column(String) # TEXT in DDL, String in SQLAlchemy is fine
    email = Column(String, index=True)
    phone = Column(String)
    sex = Column(String)

    # Relationship to device_readings
    device_readings = relationship("DeviceReading", back_populates="patient")


class DeviceReading(Base):
    __tablename__ = "device_readings"

    id = Column(String, primary_key=True, index=True) # Match DDL: VARCHAR(255)
    patient_id = Column(String, ForeignKey("patients.id", ondelete="CASCADE"), index=True) # Match DDL
    timestamp = Column(TIMESTAMP(timezone=True), nullable=False, index=True) # Match DDL
    glucose = Column(Numeric(8, 2)) # Match DDL
    systolic_bp = Column(Integer)
    diastolic_bp = Column(Integer)
    weight = Column(Numeric(8, 2)) # Match DDL

    # Relationship to patient
    patient = relationship("Patient", back_populates="device_readings")
    
    # Explicitly define the index that DBT creates (SQLAlchemy might not auto-detect composite indexes from DBT)
    # However, for mapping purposes, defining it here isn't strictly necessary if DBT manages it.
    # __table_args__ = (Index('idx_device_readings_patient_id_timestamp', "patient_id", "timestamp"),)


class PatientBiometricSummary(Base):
    # This model maps to the table/view created by DBT.
    # Column names here must match the output columns of the DBT model `patient_biometric_summary.sql`.
    __tablename__ = "patient_biometric_summary" # This is the table name generated by DBT
    # Ensure this table name matches what DBT produces (dbt typically uses model filename)

    patient_id = Column(String, ForeignKey("patients.id"), primary_key=True, index=True) 
    patient_name = Column(String)
    date_of_birth = Column(Date)
    gender = Column(String)
    sex = Column(String)
    total_readings = Column(Integer)
    min_glucose = Column(Numeric(8,2)) 
    max_glucose = Column(Numeric(8,2))
    avg_glucose = Column(Float) 
    min_systolic_bp = Column(Integer)
    max_systolic_bp = Column(Integer)
    avg_systolic_bp = Column(Float)
    min_diastolic_bp = Column(Integer)
    max_diastolic_bp = Column(Integer)
    avg_diastolic_bp = Column(Float)
    min_weight = Column(Numeric(8,2)) 
    max_weight = Column(Numeric(8,2))
    avg_weight = Column(Float)
    first_reading_timestamp = Column(TIMESTAMP(timezone=True))
    last_reading_timestamp = Column(TIMESTAMP(timezone=True))

    # If this table is in a different schema (e.g., 'analytics' created by dbt), specify it:
    # __table_args__ = {'schema': 'analytics'} 
    # For now, assuming it's in the default 'public' schema used by dbt profile.

# --- End of SQLAlchemy ORM Models ---

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Function to create all tables (if they don't exist)
def create_db_tables():
    """Creates database tables defined by SQLAlchemy models if they don't already exist."""
    try:
        print(f"Attempting to ensure all tables are created for engine: {engine.url}")
        # Base.metadata.create_all(bind=engine) # This line would create tables based on these SQLAlchemy models
        # For this project, table creation is handled by etl/loading.py (source tables)
        # and `dbt run` (staging/mart models).
        # This function is kept for potential future use if API needs to manage its own tables,
        # or for initial setup in environments where ETL/DBT haven't run.
        # For now, it's passive for the tables managed by ETL/DBT.
        print("Database table creation step (via API models) - currently passive. Tables are expected to be created by ETL/DBT.")
        pass
    except Exception as e:
        print(f"Error during table creation check/attempt: {e}")


if __name__ == "__main__":
    # Test connection
    print(f"Database URL: {DATABASE_URL}")
    try:
        with engine.connect() as connection:
            print("Successfully connected to the database using SQLAlchemy engine.")
        
        # Example of creating tables if these models were to be managed by the API
        # print("Attempting to create tables based on SQLAlchemy models (if they don't exist)...")
        # Base.metadata.create_all(bind=engine) # This would create patient_biometric_summary if it didn't exist
        # print("Table creation attempt finished.")

        # Test query if models are mapped correctly (assuming tables exist)
        # with SessionLocal() as db:
        #     from sqlalchemy import text
        #     result = db.execute(text("SELECT COUNT(*) FROM patients;"))
        #     print(f"Patient count from DB: {result.scalar_one_or_none()}")
        #     result = db.execute(text("SELECT COUNT(*) FROM patient_biometric_summary;"))
        #     print(f"Patient Biometric Summary count from DB: {result.scalar_one_or_none()} (May be 0 if DBT not run)")

    except Exception as e:
        print(f"Failed to connect or test database: {e}")
