# api/models.py
from pydantic import BaseModel, EmailStr, Field
from typing import List, Optional, Any
from datetime import date, datetime

# --- Base Schemas ---
# Common fields for creation and response can go into base models if desired.

# --- Patient Schemas ---
class PatientBase(BaseModel):
    name: str
    dob: Optional[date] = None
    gender: Optional[str] = None
    address: Optional[str] = None
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    sex: Optional[str] = None

class PatientCreate(PatientBase):
    id: str # ID is required for creation if client provides it, or generated by DB if not.
            # Current DB schema has id as PK from ETL source. API might not create new patients.
            # For now, assuming API doesn't create patients from scratch, only lists them.
            # If API were to create patients, 'id' might be optional or handled differently.

class PatientUpdate(PatientBase):
    # All fields optional for update
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    # Add other fields that can be updated by API if any

class PatientResponse(PatientBase):
    id: str # Or int, depending on actual DB type and how it's treated. Match ORM model.
    # device_readings: List['DeviceReadingResponse'] = [] # Example of nested response, if needed

    class Config:
        from_attributes = True # Changed from orm_mode = True for Pydantic V2


# --- DeviceReading Schemas ---
class DeviceReadingBase(BaseModel):
    patient_id: str # Required to link to a patient
    timestamp: datetime # ISO format string from client, converted to datetime by Pydantic
    glucose: Optional[float] = None
    systolic_bp: Optional[int] = None
    diastolic_bp: Optional[int] = None
    weight: Optional[float] = None

class DeviceReadingCreate(DeviceReadingBase):
    # For creating a new reading, usually all fields from Base are needed.
    # ID for device reading is typically generated by DB or a UUID.
    # If client provides an ID for upsert, this might change.
    # Let's assume client provides an ID for the reading for upsert.
    id: str # ID for the device reading itself

class DeviceReadingUpdate(BaseModel): # For PATCH-like updates
    timestamp: Optional[datetime] = None
    glucose: Optional[float] = None
    systolic_bp: Optional[int] = None
    diastolic_bp: Optional[int] = None
    weight: Optional[float] = None
    # patient_id generally should not be updated for an existing reading.

class DeviceReadingResponse(DeviceReadingBase):
    id: str # ID of the device reading
    # patient: Optional[PatientResponse] = None # Example of nested patient response

    class Config:
        from_attributes = True


# --- Biometric Summary Schemas ---
# This schema is for data read from the dbt-generated summary table.
class BiometricSummaryResponse(BaseModel):
    patient_id: str
    patient_name: Optional[str] = None
    date_of_birth: Optional[date] = None
    gender: Optional[str] = None
    sex: Optional[str] = None
    total_readings: Optional[int] = None
    min_glucose: Optional[float] = None # Pydantic will handle Numeric from DB as float
    max_glucose: Optional[float] = None
    avg_glucose: Optional[float] = None
    min_systolic_bp: Optional[int] = None
    max_systolic_bp: Optional[int] = None
    avg_systolic_bp: Optional[float] = None
    min_diastolic_bp: Optional[int] = None
    max_diastolic_bp: Optional[int] = None
    avg_diastolic_bp: Optional[float] = None
    min_weight: Optional[float] = None
    max_weight: Optional[float] = None
    avg_weight: Optional[float] = None
    first_reading_timestamp: Optional[datetime] = None
    last_reading_timestamp: Optional[datetime] = None

    class Config:
        from_attributes = True


# --- Pagination Schemas ---
class PaginatedResponse(BaseModel):
    total_count: int
    limit: int
    offset: int
    data: List[Any] # Generic data field, will be specified by specific response model

class PaginatedPatientResponse(PaginatedResponse):
    data: List[PatientResponse]

class PaginatedDeviceReadingResponse(PaginatedResponse):
    data: List[DeviceReadingResponse]

class PaginatedBiometricSummaryResponse(PaginatedResponse):
    data: List[BiometricSummaryResponse]

# Forward references for nested models if they were in different files or order.
# Not strictly needed here as models are in order, but good practice if structure changes.
# PatientResponse.update_forward_refs()
# DeviceReadingResponse.update_forward_refs()
